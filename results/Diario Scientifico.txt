08/12/2025
Non c'è un modo per includere il caricamento delle librerie nel calcolo del tempo in c++ e java
Perciò o si esclude anche in python, o si utilizza un comando nella powershell che calcoli anche il processo di compilazione

LibreOffice

04/12/2025
Anche in c++ devo manualmente cambiare i valori float in interi binari e inserire il calcolo per l'mcc

Per stampare diverse cifre decimali:
#include <limits>
#include <iomanip>
//cout << setprecision(numeric_limits<double>::max_digits10) << tuo_numero << endl;
//cout << fixed << setprecision(4);


01/12/2025
Devo anche qui creare un doppio ciclio for per la LOOCV


29/11/2025
In c++ devo leggere il file csv e trasformare i dati in matrici eigen da poter poi utilizzare nelle operazioni matematiche


25/11/2025
Per avviare il file java andare con cd nella cartella bin e usare il comando:
java --add-opens java.base/java.lang=ALL-UNNAMED -cp ".;../../src/java/weka.jar;../../src/java/mtj.jar;../../src/java/arpack_combined.jar;../../src/java/core.jar" proj


24/11/2025
Per calcolare il consumo energetico in python si può usare la libreria codecarbon:
tracker.start()
tracker.stop()
energia_kwh = tracker.final_emissions_data.energy_consumed
print(f"Consumo Energetico: {energia_kwh:.8f} kWh")


21/11/2025
Per compilare file c++ spostarsi nella cartella c++ in src e scrivere:
g++ -I "(percorso_cartella_eigen)" -O3 main.cpp -o programma.exe

Per avviarlo scrivere:
.\programma.exe


20/11/2025
Per la regressione lineare in c++ serve la libreria Eigen


18/11/2025
Per calcolare tempo d'esecuzione del programma in c++ usare la libreria chrono:
auto start = std::chrono::high_resolution_clock::now();
auto end = std::chrono::high_resolution_clock::now();


12/11/2025
LinearRegression lr = new LinearRegression() per usare la regressione lineare
Usiamo lr.buildClassifier(Instances data) per il training e double pred = lr.classifyInstance(test.instance(Instance instance)) per il testing

Per calcolare la durata d'esecuzione usare System.nanoTime()


10/11/2025
Per valutare il modello deovremmo usare il metodo crossValidateModel() di weka ma nel nostro caso non è adeguato perché dobbiamo applicare una binarizzazzione dei dati e trovare mcc con regressione lineare
Perciò dobbiamo implementare manualmente un ciclo che replica il loocv
Fatto ciò dobbiamo binarizzare i dati ottenuti e poi calcolare manualmente il mcc


07/11/2025
Usare CSVLoader per leggere i file di dati
Usare data.removeIf(Instance::hasMissingValue); per rimuovere valori non numerici


05/11/2025
Per java bisogna usare la libreria weka


03/11/2025
Sito tutorial per machine learning java: https://www.geeksforgeeks.org/machine-learning/machine-learning-with-java/


31/10/2025
Codice per trovare il mcc:
matthews_corrcoef(y, predictions)

Per trovare il mcc non si può usare il codice precedente perché le predictions sono float, perciò bisogna arrotondarle

Per calcolare il tempo di esecuzione del programma basta usare il modulo time:
start_time = time.time()
...
print("--- %s seconds ---" % (time.time() - start_time))

L'arrotondamento con round() è concettualmente sbagliato perciò bisogna necessariamente usare un if else con x>0.5


30/10/2025
Se voglio trovare sia mse che r2 devo usare cross_validate:
scoring_metrics = ['neg_mean_squared_error', 'r2']
cv_results = cross_validate(model, x, y, cv=loo, 
                            scoring=scoring_metrics)
mean_r2 = np.mean(cv_results['test_r2'])
mean_mse = -np.mean(cv_results['test_neg_mean_squared_error'])

Non si può applicare il codice precedente per trovare r2 con la loocv perché c'è un solo dato test ad ogni iterazione, bisogna fare così:
y_predictions = cross_val_predict(model, x, y, cv=loo)
mse = mean_squared_error(y, y_predictions)
r2 = r2_score(y, y_predictions)


29/10/2025
Codice per implementare Leave-One-Out-Cross-Validation e ottenere mse:
loo = LeaveOneOut()
scores = cross_val_score(model, x, y, cv=loo, scoring='neg_mean_squared_error')
mse = -np.mean(scores)
rmse = np.sqrt(mse)
(si può sostituire model con LinearRegression e loo con LeaveOneOut)
(scoring='neg_mean_squared_error' serve per usare mse, in quanto di default viene usato r2)
(questo fa si che i valori di scores vengano invertiti e perciò e poi necessario invertire anche mse)


28/10/2025
Codice per applicare modello di regressione lineare:
model = LinearRegression().fit(x, y)

Codice per predirre risultati:
y_new = model.predict(x_new)
y_new


27/10/2025
Codice per trasformare file csv in array (skip_header=1 serve per saltare la prima riga):
from numpy import genfromtxt
my_data = genfromtxt('my_file.csv', delimiter=',', skip_header=1)

Codice per ignorare valori non numerici (rende inutile skip_header se usato):
my_data = my_data[~np.isnan(my_data).any(axis=1)]

Codice per prendere solo l'ultima colonna per y e tutte le altre per x:
x = my_data[:, :-1]
y = my_data[:, -1]

Codice per stampare un array intero:
np.set_printoptions(threshold=np.inf)


24/10/2025
Sito tutorial ML Python: https://realpython.com/linear-regression-in-python/#multiple-linear-regression-with-scikit-learn


23/10/2025
Librerie utili: NumPy e scikit-learn


17/10/2025
Sito teorico machine learning: https://www.geeksforgeeks.org/machine-learning/machine-learning/